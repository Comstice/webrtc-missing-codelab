<html>
<head>
    <script src="https://webrtc.github.io/adapter/adapter-latest.js"></script>
    <style>
.container {
    margin: 0 auto 0 auto;
    max-width: 60em;
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    grid-gap: 10px;
}

.videocontainer {
    position: relative;
}

.left {
    grid-column: 1/2;
}
.right{
    grid-column: 2/2;
}

.muted {
    color: red;
}

.sharing {
    color: red;
}

video {
    height: 480px;
    width: 640px;
}

#localVideo {
    transform: scale(-1, 1);
}

button {
    background-color: rgb(58, 200, 143);
    border: none;
    border-radius: 2px;
	box-shadow: none;
	padding: 13px 40px !important;
    color: white;
}

body {
    background-image: url("https://bloggeek.me/wp-content/uploads/2020/02/bloggeekme.png");
    background-position: right bottom;
    background-repeat: no-repeat;
}
  </style>
</head>
<body>
    <div class="container">
        <div class="videocontainer left">
            <video id="localVideo" autoplay muted playsinline></video>
        </div>
        <div class="videocontainer right">
            <video id="remoteVideo" autoplay playsinline></video>
        </div>
        <div class="left">
            <p>Client ID: <span id="clientId"></span></p>
            <p>
                <button id="audioBtn">mute audio</button>
                <button id="videoBtn">mute video</button>
                <button id="shareBtn">share screen</button>
            </p>
        </div>
        <div class="right">
            <p>Peer ID: <span id="peerId"></span></p>
            <p>
                <button id="hangupButton" disabled>hangup</button>
            </p>
        </div>
    </div>
    <script>
const hangupBtn = document.getElementById('hangupButton');
hangupBtn.addEventListener('click', () => {
    hangupBtn.disabled = true;
    peers.forEach((pc, id) => {
        hangup(id);
    });
});

// Audio and video muting.
const audioBtn = document.getElementById('audioBtn');
audioBtn.addEventListener('click', () => {
    const audioTrack = localStream.getAudioTracks()[0];
    if (audioTrack.enabled) {
        audioBtn.classList.add('muted');
    } else {
        audioBtn.classList.remove('muted');
    }
    audioTrack.enabled = !audioTrack.enabled;
});
const videoBtn = document.getElementById('videoBtn');
videoBtn.addEventListener('click', () => {
    const videoTrack = localStream.getVideoTracks()[0];
    if (videoTrack.enabled) {
        videoBtn.classList.add('muted');
    } else {
        videoBtn.classList.remove('muted');
    }
    videoTrack.enabled = !videoTrack.enabled;
    // The advanced version of this stops the track to disable and uses
    // replaceTrack to re-enable. Not necessary in Firefox which turns
    // off the camera light.
});

// Relatively self-contained screensharing/replaceTrack example.
let screenShare;
function replaceVideoTrack(withTrack) {
    peers.forEach(pc => {
        const sender = pc.getSenders().find(s => s.track && s.track.kind === 'video');
        if (sender) {
            sender.replaceTrack(withTrack);
        }
    });
}
const shareBtn = document.getElementById('shareBtn');
shareBtn.addEventListener('click', async () => {
    if (screenShare) { // click-to-end.
        screenShare.getTracks().forEach(t => t.stop());
        screenShare = null;
        document.getElementById('localVideo').srcObject = localStream;
        replaceVideoTrack(localStream.getVideoTracks()[0]);
        shareBtn.classList.remove('sharing');
        return;
    }
    const stream = await navigator.mediaDevices.getDisplayMedia({video: true});
    const track = stream.getVideoTracks()[0];
    replaceVideoTrack(track);
    document.getElementById('localVideo').srcObject = stream;
    track.addEventListener('ended', () => {
        console.log('Screensharing ended via the browser UI');
        screenShare = null;
        document.getElementById('localVideo').srcObject = localStream;
        replaceVideoTrack(localStream.getVideoTracks()[0]);
        shareBtn.classList.remove('sharing');
    });
    screenShare = stream;
    shareBtn.classList.add('sharing');
});
// End of screensharing

const protocol = window.location.protocol === 'https' ? 'wss' : 'ws';
const peers = new Map(); // A map of all peer ids to their peerconnections.
let clientId; // our client id
let ws; // our websocket
let localStream;

async function getUserMedia() {
    const stream = await navigator.mediaDevices.getUserMedia({audio: true, video: true});
    document.getElementById('localVideo').srcObject = stream;
    return stream;
}

function connect() {
    return new Promise((resolve, reject) => {
        ws = new WebSocket(protocol + '://' + window.location.host);
        ws.addEventListener('open', () => {
            console.log('websocket opened');
            resolve();
        });
        ws.addEventListener('error', (e) => {
            console.log('websocket error, is the server running?', e);
            reject(e);
        });
        ws.addEventListener('close', (e) => {
            console.log('websocket closed', e);
        });
        ws.addEventListener('message', async (e) => {
            let data;
            try {
                data = JSON.parse(e.data);
            } catch(err) {
                console.log('Received invalid JSON', err, e.data);
                return;
            }
            switch(data.type) {
            case 'hello':
                clientId = data.id;
                document.getElementById('clientId').innerText = clientId;
                window.location.hash = clientId;
                break;
            case 'bye':
                if (peers.has(data.id)) {
                    peers.get(data.id).close();
                    peers.delete(data.id);
                } else {
                    console.log('Peer not found', data.id);
                }
                break;
            case 'offer':
                if (!peers.has(data.id)) {
                    console.log('Incoming call from', data.id);
                    document.getElementById('peerId').innerText = data.id;
                    if (peers.size >= 1) { // Already in a call. Reject.
                        console.log('Already in a call, rejecting');
                        ws.send(JSON.stringify({
                            type: 'bye',
                            id: data.id,
                        }));
                        return;
                    }
                    // Create a new peer.
                    const pc = createPeerConnection(data.id);
                    if (localStream) {
                        localStream.getTracks().forEach(t => pc.addTrack(t, localStream));
                    }
                    await pc.setRemoteDescription({
                        type: data.type,
                        sdp: data.sdp
                    });
                    const answer = await pc.createAnswer();
                    await pc.setLocalDescription(answer);
                    ws.send(JSON.stringify({
                        type: 'answer',
                        sdp: answer.sdp,
                        id: data.id,
                    }));
                    hangupBtn.disabled = false;
                } else {
                    console.log('Subsequent offer not implemented');
                }
                break;
            case 'answer':
                if (peers.has(data.id)) {
                    const pc = peers.get(data.id);
                    await pc.setRemoteDescription({
                        type: data.type,
                        sdp: data.sdp
                    });
                } else {
                    console.log('Peer not found', data.id);
                }
                break;
            case 'candidate':
                if (peers.has(data.id)) {
                    const pc = peers.get(data.id);
                    console.log('addIceCandidate', data);
                    await pc.addIceCandidate(data.candidate);
                } else {
                    console.log('Peer not found', data.id);
                }
                break;
            default:
                console.log('Unhandled', data);
                break;
            }
        });
    });
}

function createPeerConnection(id) {
    const pc = new RTCPeerConnection(); // no ice servers.
    pc.addEventListener('icecandidate', (e) => {
        ws.send(JSON.stringify({
            type: 'candidate',
            candidate: e.candidate,
            id,
        }));
    });
    pc.addEventListener('track', (e) => {
        const remoteVideo = document.getElementById('remoteVideo');
        remoteVideo.onloadedmetadata = () => {
            // called when the first frame is rendered.
            console.log(id, 'loaded metadata');
        };
        remoteVideo.srcObject = e.streams[0];
    });
    pc.addEventListener('iceconnectionstatechange', () => {
        console.log(id, 'iceconnectionstatechange', pc.iceConnectionState);
        hangupBtn.disabled = false;
    });
    pc.addEventListener('connectionstatechange', () => {
        console.log(id, 'connectionstatechange', pc.connectionState);
    });
    pc.addEventListener('signalingstatechange', () => {
        console.log(id, 'signalingstatechange', pc.signalingStateChange);
    });
    peers.set(id, pc);
    return pc;
}

async function call(id) {
    if (peers.has(id)) {
        console.log('it seems you are already in a call with', id);
        return;
    }
    const pc = createPeerConnection(id);
    if (localStream) {
        localStream.getTracks().forEach(t => pc.addTrack(t, localStream));
    }
    const offer = await pc.createOffer();
    await pc.setLocalDescription(offer);
    ws.send(JSON.stringify({
        type: 'offer',
        sdp: offer.sdp,
        id,
    }));
    hangupBtn.disabled = false;
    document.getElementById('peerId').innerText = id;
}

function hangup(id) {
    if (!peers.has(id)) {
        console.log('no such peer');
        return;
    }
    const pc = peers.get(id);
    pc.close();
    peers.delete(id);
    // Tell the other side
    ws.send(JSON.stringify({
        type: 'bye',
        id,
    }));
}

// Autoconnect when given a peer id.
const initialHash = window.location.hash.substr(1);

// Get the camera, then connect to signaling. Makes things simple.
getUserMedia()
  .then((stream) => {
    localStream = stream;
    return connect();
})
.then(() => {
    if (initialHash.length) {
        call(initialHash);
    }
});
    </script>
</body>
